<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Raycaster</title>
    <!-- <script
          src="https://code.jquery.com/jquery-3.3.1.min.js"
          integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
          crossorigin="anonymous"></script>-->
</head>
<body>
    <canvas id="screen"></canvas>
    <canvas id="minimap"></canvas>
    <script src="./globals.js"></script>
    <script>
        /* On document loaded */
        document.addEventListener("DOMContentLoaded", function(){
            MapWidth = Map[0].length;
            MapHeight = Map.length;

            screenInit();
            bindKeys();
            drawMiniMap();
            gameCycle();
        }, false);

        function screenInit(){
            var screen_canvas = document.getElementById("screen");
            screen_canvas.width = ScreenWidth;
            screen_canvas.height = ScreenHeight;

        }

        function bindKeys(){
            document.onkeydown = function(e) {
                e = e || window.event;
                switch(e.keyCode) {
                    case 38: //Up
                        player.speed = 1;
                        break;
                    case 40: //Down
                        player.speed = -1;
                        break;
                    case 37: //Left
                        player.dir = -1;
                        break;
                    case 39: //Right
                        player.dir = 1;
                        break;
                }
            }

            document.onkeyup = function(e) {
                e = e || window.event;
                switch(e.keyCode){
                    case 38:
                    case 40:
                        player.speed = 0;
                        break;
                    case 37:
                    case 39:
                        player.dir = 0;
                        break;
                }
            }
        }

        function drawMiniMap() {
            //Draw topdown view of minimap
            var miniMap = document.getElementById("minimap");
            //Resize the internal canvas dimensions
            miniMap.width = MapWidth * MiniMapScale;
            miniMap.height = MapHeight * MiniMapScale;
            //Reize the canvas CSS dimensions
            miniMap.style.width = (MapWidth * MiniMapScale) + "px";
            miniMap.style.height = (MapHeight * MiniMapScale) + "px";

            //Loop through all blocks on the map
            var ctx = miniMap.getContext("2d");
            for(let y = 0; y < MapHeight; y++){
                for(let x = 0; x < MapWidth; x++){
                    //If there is a wall block at this (x,y)...
                    if(Map[y][x] > 0) {
                        ctx.fillStyle = "rgb(200, 200, 200)"; //Set draw color
                        ctx.fillRect(x * MiniMapScale, y * MiniMapScale, MiniMapScale, MiniMapScale);
                    }
                }
            }

            //Actual draw location of player should be modified by scaling factor
            var actualPlayerX = player.x*MiniMapScale-2;
            var actualPlayerY = player.y*MiniMapScale-2;

            //Draw player
            ctx.fillStyle = "rgb(100, 100, 0)";
            ctx.fillRect(actualPlayerX, actualPlayerY, MiniMapScale/2, MiniMapScale/2);
        }

        function gameCycle(){
            move();
            drawMiniMap();
            castRays();
            setTimeout(gameCycle, 1000/30); //30 Frames babyyy
        }

        var player = {
            x : 5,
            y : 2,
            dir : 0, //turning direction, left or right
            speed : 0, //forward -> 1, backwards -> -1
            rot : 0, // angle of rotation
            moveRate : 0.18,
            rotRate : 6 * Math.PI/180 //rate of rotation
        }

        function move(){
            var moveStep = player.speed * player.moveRate; //determines how far player should move
            player.rot += player.dir * player.rotRate; //rotation modified by direction

            // Calculate new x, y pos of player with trig
            var newX = player.x + Math.cos(player.rot) * moveStep; //Cos gets the x value of rotation, which determines how far along the x axix moveStep should being modified
            var newY = player.y + Math.sin(player.rot) * moveStep;

            // Check if new x, y is out of bounds
            if (newY < 0 || newY >= MapHeight*MiniMapScale || newX < 0 || newX >= MapWidth*MiniMapScale) {
                console.log(newX + " " + newY);
                return;
            }

            // Check if new x, y is occupying a wall
            // Use both ceil and floor to consider both ends of the walls
            if(Map[Math.ceil(newY)][Math.ceil(newX)] != 0 || Map[Math.floor(newY)][Math.floor(newX)] != 0){
                return;
            }

            // Set new position
            player.x = newX;
            player.y = newY;
        }

        function castRays(){
            for(let i = 0; i < NumStrips; i++){
                var ray_screen_pos = (-NumStrips/2 + i) * StripWidth;
                var ray_view_dist = Math.sqrt(ray_screen_pos*ray_screen_pos + ViewDist*ViewDist);
                var ray_angle = Math.asin(ray_screen_pos / ray_view_dist);

                castSingleRay(player.rot+ray_angle);

            }
        }
        function castSingleRay(rayAngle) {

            let twoPI = Math.PI * 2;

            // first make sure the angle is between 0 and 360 degrees
            rayAngle %= twoPI;
            if (rayAngle < 0) rayAngle += twoPI;

            // moving right/left? up/down? Determined by which quadrant the angle is in.
            var right = (rayAngle > twoPI * 0.75 || rayAngle < twoPI * 0.25);
            var up = (rayAngle < 0 || rayAngle > Math.PI);

            // only do these once
            var angleSin = Math.sin(rayAngle);
            var angleCos = Math.cos(rayAngle);


            var dist = 0;   // the distance to the block we hit
            var xHit = 0;   // the x and y coord of where the ray hit the block
            var yHit = 0;

            var textureX;   // the x-coord on the texture of the block, ie. what part of the texture are we going to render
            var wallX;  // the (x,y) Map coords of the block
            var wallY;


            // first check against the vertical Map/wall lines
            // we do this by moving to the right or left edge of the block we're standing in
            // and then moving in 1 Map unit steps horizontally. The amount we have to move vertically
            // is determined by the slope of the ray, which is simply defined as sin(angle) / cos(angle).

            var slope = angleSin / angleCos; 	// the slope of the straight line made by the ray
            var dX = right ? 1 : -1;    // we move either 1 Map unit to the left or right
            var dY = dX * slope;    // how much to move up or down

            var x = right ? Math.ceil(player.x) : Math.floor(player.x);	// starting horizontal position, at one of the edges of the current Map block
            var y = player.y + (x - player.x) * slope;  // starting vertical position. We add the small horizontal step we just made, multiplied by the slope.

            while (x >= 0 && x < MapWidth && y >= 0 && y < MapHeight) {
                var wallX = Math.floor(x + (right ? 0 : -1));
                var wallY = Math.floor(y);

                // is this point inside a wall block?
                if (Map[wallY][wallX] > 0) {

                    var distX = x - player.x;
                    var distY = y - player.y;
                    dist = distX*distX + distY*distY;   // the distance from the player to this point, squared.

                    textureX = y % 1;   // where exactly are we on the wall? textureX is the x coordinate on the texture that we'll use when texturing the wall.
                    if (!right) textureX = 1 - textureX; // if we're looking to the left side of the Map, the texture should be reversed

                    xHit = x;   // save the coordinates of the hit. We only really use these to draw the rays on miniMap.
                    yHit = y;

                    break;
                }
                x += dX;
                y += dY;
            }



            // now check against horizontal lines. It's basically the same, just "turned around".
            // the only difference here is that once we hit a Map block, 
            // we check if there we also found one in the earlier, vertical run. We'll know that if dist != 0.
            // If so, we only register this hit if this distance is smaller.

            var slope = angleCos / angleSin;
            var dY = up ? -1 : 1;
            var dX = dY * slope;
            var y = up ? Math.floor(player.y) : Math.ceil(player.y);
            var x = player.x + (y - player.y) * slope;

            while (x >= 0 && x < MapWidth && y >= 0 && y < MapHeight) {
                var wallY = Math.floor(y + (up ? -1 : 0));
                var wallX = Math.floor(x);
                if (Map[wallY][wallX] > 0) {
                    var distX = x - player.x;
                    var distY = y - player.y;
                    var blockDist = distX*distX + distY*distY;
                    if (!dist || blockDist < dist) {
                        dist = blockDist;
                        xHit = x;
                        yHit = y;
                        textureX = x % 1;
                        if (up) textureX = 1 - textureX;
                    }
                    break;
                }
                x += dX;
                y += dY;
            }

            if (dist) {
                drawRay(xHit, yHit, player.x, player.y);
            }

        }

        function drawRay(ray_x, ray_y, p_x, p_y){
            var minimap = document.getElementById("minimap");
            var ctx = minimap.getContext("2d");

            ctx.strokeStyle = "rgba(100, 0, 0, 0.3)";
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(p_x*MiniMapScale, p_y*MiniMapScale);
            ctx.lineTo(ray_x*MiniMapScale, ray_y*MiniMapScale);
            ctx.closePath();
            ctx.stroke();
        }
    </script>
</body>
</html>
