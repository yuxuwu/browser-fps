<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Raycaster</title>
    <!-- <script
          src="https://code.jquery.com/jquery-3.3.1.min.js"
          integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
          crossorigin="anonymous"></script>-->
</head>
<body>
    <canvas id="minimap"></canvas>
    <script>

        // a 32x7 block map
        var map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,2,0,0,0,0,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        var mapWidth = 0;
        var MapHeight = 0;
        var miniMapScale = 8;

        /* On document loaded */
        document.addEventListener("DOMContentLoaded", function(){
            mapWidth = map[0].length;
            mapHeight = map.length;

            bindKeys();
            drawMiniMap();
            gameCycle();
        }, false);

        function bindKeys(){
            document.onkeydown = function(e) {
                e = e || window.event;
                switch(e.keyCode) {
                    case 38: //Up
                        player.speed = 1;
                        break;
                    case 40: //Down
                        player.speed = -1;
                        break;
                    case 37: //Left
                        player.dir = -1;
                        break;
                    case 39: //Right
                        player.dir = 1;
                        break;
                }
            }

            document.onkeyup = function(e) {
                e = e || window.event;
                switch(e.keyCode){
                    case 38:
                    case 40:
                        player.speed = 0;
                        break;
                    case 37:
                    case 39:
                        player.dir = 0;
                        break;
                }
            }
        }

        function drawMiniMap() {
            //Draw topdown view of minimap
            var miniMap = document.getElementById("minimap");
            //Resize the internal canvas dimensions
            miniMap.width = mapWidth * miniMapScale;
            miniMap.height = mapHeight * miniMapScale;
            //Reize the canvas CSS dimensions
            miniMap.style.width = (mapWidth * miniMapScale) + "px";
            miniMap.style.height = (mapHeight * miniMapScale) + "px";

            //Loop through all blocks on the map
            var ctx = miniMap.getContext("2d");
            for(let y = 0; y < mapHeight; y++){
                for(let x = 0; x < mapWidth; x++){
                    //If there is a wall block at this (x,y)...
                    if(map[y][x] > 0) {
                        ctx.fillStyle = "rgb(200, 200, 200)"; //Set draw color
                        ctx.fillRect(x * miniMapScale, y * miniMapScale, miniMapScale, miniMapScale);
                    }
                }
            }

            //Actual draw location of player should be modified by scaling factor
            var actualPlayerX = player.x*miniMapScale;
            var actualPlayerY = player.y*miniMapScale;

            //Draw player
            ctx.fillStyle = "rgb(100, 100, 0)";
            ctx.fillRect(actualPlayerX, actualPlayerY, miniMapScale, miniMapScale);
            /*
            //Draw little 'protrusion' from front of player to tell rot
            ctx.beginPath();
            ctx.moveTo(actualPlayerX + miniMapScale/2, actualPlayerY + miniMapScale/2);
            ctx.lineTo(actualPlayerX + Math.cos(player.rot) * 32, actualPlayerY + Math.sin(player.rot) * 32);
            ctx.stroke(); //stroke it dude
            */
        }

        function gameCycle(){
            move();
            drawMiniMap();
            castRays();
            setTimeout(gameCycle, 1000/30); //30 Frames babyyy
        }

        var player = {
            x : 5,
            y : 2,
            dir : 0, //turning direction, left or right
            speed : 0, //forward -> 1, backwards -> -1
            rot : 0, // angle of rotation
            moveRate : 0.18,
            rotRate : 6 * Math.PI/180 //rate of rotation
        }

        function move(){
            var moveStep = player.speed * player.moveRate; //determines how far player should move
            player.rot += player.dir * player.rotRate; //rotation modified by direction

            // Calculate new x, y pos of player with trig
            var newX = player.x + Math.cos(player.rot) * moveStep; //Cos gets the x value of rotation, which determines how far along the x axix moveStep should being modified
            var newY = player.y + Math.sin(player.rot) * moveStep;

            // Check if new x, y is out of bounds
            if (newY < 0 || newY >= mapHeight*miniMapScale || newX < 0 || newX >= mapWidth * miniMapScale) {
                console.log(newX + " " + newY);
                return;
            }

            // Check if new x, y is occupying a wall
            // Use both ceil and floor to consider both ends of the walls
            if(map[Math.ceil(newY)][Math.ceil(newX)] != 0 || map[Math.floor(newY)][Math.floor(newX)]){
                return;
            }

            // Set new position
            player.x = newX;
            player.y = newY;
        }

        function castRays(){
            var num_rays = 320;
            var fov = 60 * Math.PI/180;
            var angle_increment = fov/320;;

            var miniMap = document.getElementById("minimap");
            var ctx = miniMap.getContext("2d");

            for(let i = 0; i < 320; i++){
                //cast ray from player until it hits wall
                var ray_hit = castSingleRay(player.rot+angle_increment*i, player.x, player.y); //angle_increment*i to get next angle
                //draw where ray was hit
                ctx.beginPath();
                ctx.moveTo(player.x*miniMapScale + miniMapScale/2, player.y*miniMapScale + miniMapScale/2);
                ctx.lineTo(ray_hit.xHit*8, ray_hit.yHit*8);
                ctx.stroke();
            }
        }

        function castSingleRay(angle, p_x, p_y){
            // Intermittent variable declarations
            var xHit_vert, yHit_vert;
            var xHit_horiz, yHit_horiz;
            var dX, dY;
            var x, y;

            angle %= Math.PI * 2; // don't let angles exceed 2PI
            if(angle > 0) angle += Math.PI*2;

            var vertical_dist = Number.MAX_SAFE_INTEGER;
            var horizontal_dist = Number.MAX_SAFE_INTEGER;
            var up, right;

            // Check which way the angle is facing
            up = (Math.sin(angle) > 0) ? true : false;
            right = (Math.cos(angle) > 0) ? true : false;

            // Find vertical distance by getting only vertical grid lines
            dX = right ? 1 : -1; //change over x
            dY = dX * Math.tan(angle); //change over y
            // Find first x, y position
            x = right ? Math.ceil(p_x) : Math.floor(p_x);
            y = p_y + (x-p_x)*Math.tan(angle);
            // Find vertical wall
            while( x >= 0 && x < mapWidth && y >= 0 && y < mapHeight ){
                var add = right ? 0 : -1;
                var wallX = Math.floor(x + add);
                var wallY = Math.floor(y);
                // Check if point is inside wall
                if(map[wallY][wallX] > 0){
                    var distX = x - player.x;
                    var distY = y - player.y;
                    vertical_dist = distX*distX + distY*distY; //pythagoras
                    xHit_vert = x;
                    yHit_vert = y;
                    break;
                }
                x += dX;
                y += dY
            }

            // Find horizontal distance by getting only horizontal grid lines
            dY = up ? 1 : -1;
            dX = dY/Math.tan(angle);
            // Find first x, y position
            y = up ? Math.ceil(p_y) : Math.floor(p_y);
            x = p_x + (y-p_y)/Math.tan(angle);
            // Find horizontal wall
            while( x >= 0 && x < mapWidth && y >= 0 && y < mapHeight ){
                var add = up ? 0 : -1;
                var wallY = Math.floor(y + add);
                var wallX = Math.floor(y);
                // Check if point is inside wall
                if(map[wallY][wallX] > 0){
                    var distX = x - player.x;
                    var distY = y - player.y;
                    horizontal_dist = distX*distX + distY*distY; //pythagoras
                    xHit_horiz = x;
                    yHit_horiz = y;
                    break;
                }
                x += dX;
                y += dY;
            }

            if(vertical_dist > horizontal_dist){
                return {xHit: xHit_vert, yHit: yHit_vert};
            } else {
                return {xHit: xHit_horiz, yHit: yHit_horiz};
            }
        }
    </script>
</body>
</html>
